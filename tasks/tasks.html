<h3>Task 1</h3>

<h5>Description</h5>

<p>In this stage, complete the following steps:</p>

<ol>
	<li> Learn how to make context windows out of a dictionary with positions;</li>
	<li> Combine the first step with the features from the previous stages. The program should return windows, processed as in the previous stage.</li>
</ol>

<h5>Objectives</h5>

<p>Your program is given a folder with files. The program processes them and returns a dictionary with context windows. Then these windows should be converted into a dictionary with combined and expanded windows with their number adjusted by limit and offset.</p>

<p>In more detail, it should do the following:</p>

<ol>
	<li>Take an input that consists of a dictionary, a query, a window size, a limit, and an offset: <code class="java">input_dictionary,query='man', window_size=1, limit=1, offset=0</code>.</li>
	<li>A dictionary can look like this: <code class="java">{'filename.txt': [first_position, second_position, ...]}</code> , it is the result of the search. Note that the context window size remains constant;</li>
	<li>Iterate over all positions in each file;</li>
	<li>Create a context window from each position;</li>
	<li>Save context windows in a corresponding dictionary: <code class="java">{'filename.txt': [window1, window2, ...]}</code>;</li>
	<li>Extend all windows to match sentences;</li>
	<li>Test whether the windows overlap. If so, merge them into one and save only the result of merging. Note that before this step you worked only with two windows that either overlapped or not. Now, you have a dictionary with a lot of windows, so you should iterate over the dictionary, taking two consecutive windows each time to check whether they overlap or not. If they do not overlap, take the next two consecutive windows and repeat the action;</li>
	<li>Save the results in the output dictionary: <code class="java">{'filename.txt': [window1, window2, ...]}</code>. Do not forget that you need to save as many files with their context window lists as indicated in the limit. Start from the index of the result that is indicated in the offset; see the example below;</li>
	<li>Sort the dictionary in ascending order and print the result in the following format: <code class="java">filename_1: list with windows_1\nfilename_2: list with windows_2</code></li>
	<li>Clear the database after indexing</li>
</ol>

<h5>Examples</h5>

<p>The greater-than symbol followed by a space (<code class="java">&gt; </code>) represents the user input. Note that it's not part of the input.</p>

<p>During tests, you are given a test folder. Input is a folder path, where you need to find and process all text files. Your program should take this path and iterate over files. Clear your database after each test.</p>

<p><strong>Example 1</strong>:</p>

<p>Folder contents: <em>testfile1.txt, testfile2.txt.</em></p>

<p><em>testfile1.txt </em>contents:<br>
<code class="java">It seemed a delightful prospect. This man evidently understands my complaint.</code></p>

<p><em>testfile2.txt </em>contents:<br>
<code class="java">Every possible situation man could imagine has been spoilt.</code></p>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; tests/stage6/ex1
&gt; 'man',1,1,0
testfile1.txt: ['It seemed a delightful prospect. This man evidently understands my complaint.|[[0, 38, 41]]|33|78']</code></pre>

<p><strong>Example 2</strong>:</p>

<p>Folder contents: <em>testfile3.txt</em>.</p>

<p><em>testfile3.txt </em>contents:</p>

<pre><code class="language-no-highlight">There’s enough water to see, right?
To tell the truth, it was water from the river, too.</code></pre>

<p>Output: </p>

<pre><code class="language-no-highlight">&gt; tests/stage6/ex2
&gt; 'water',1,2,0
testfile3.txt: ['There’s enough water to see, right?|[[0, 15, 20]]|0|36', 'To tell the truth, it was water from the river, too.|[[1, 26, 31]]|0|53']</code></pre>

<h3>Task 2</h3>

<h5>Description</h5>

<p>In this stage, you will create a database that stores unique tokens and their positions in the text. Imagine a document contains only one line: <code class="java">John is a 4th-year student</code>, so the resulting <span style="background-color: transparent; color: #000000; font-size: 11pt; font-variant: normal;"><code class="java">("student", 19, "alpha")</code> </span>token is stored in line no. 0 (remember, enumeration starts from zero!). The token starts at 19, which is already known from the previous step, and ends at 19 + 7 = 26 as there are seven letters in the word <code class="java">student</code>. The indexer should take tokens as <span style="background-color: transparent; color: #000000; font-size: 11pt; font-variant: normal;"><code class="java">("student", 19, "alpha")</code> </span>and generate their positions, for example <span style="background-color: transparent; color: #000000; font-size: 11pt; font-variant: normal;"><code class="java">("student", 0, 19, 26)</code>.</span> The indexer works the same way as the tokenizer: it does not store anything in memory, it generates and outputs the results for each token. It should work when the file is empty. In this case, the program should output <code class="java">None</code>.</p>

<h5>Objectives</h5>

<p>In this stage, you need to write an indexer that assigns a search index (a list of positions) to tokens and creates a structure that will store the information about these indexes. Please note that:</p>

<ul>
	<li>The input is a path to the folder with files; the indexer should take their names one by one and implement indexing for each file; the output is a database, which looks like this: <code class="java">{'word': {'filename.txt': [position1, position2, ...]}, 'word2': ...}</code>.</li>
	<li>The positions of tokens (the <code class="java">[position1, position2, ...]</code> list) should be stored in ascending order, line by line, from the very first line in the file to the very end of the very last line in the same file.</li>
	<li>The ascending order is based on how many lines a file contains, and what the starting and ending indexes are. For example, a position instance found in the first line of the file will be placed before the position found in the second line of the file. If both positions are found in the same line, the position with a smaller starting index will be placed first. If both positions are found in the same line and have the same starting index, the position with a smaller ending index will be placed first. </li>
</ul>

<p>Don't<span style="color: #ff4363;"> </span>forget to print the resulting dictionary.</p>

<p>You may want to write your own test programs that will check your code. Check whether it takes the right input format, that it can work with any number of files, and saves the positions of each token. Note that when writing tests, you need to create your own text files, tokenize and index them, and build a small test base using the indexer.</p>

<p>At the end of the day, your indexer should:</p>

<ol>
	<li>Take a directory path as input, find all <em>.txt </em>files, and start processing them one by one,</li>
	<li>Read each file line by line,</li>
	<li>Implement tokenization from the previous step,</li>
	<li>Produce token pairs and their indexes (positions),</li>
	<li>Add these pairs to the database.</li>
</ol>

<p>Do not create a new database each time you add a new file, just add new tokens and positions to the same database. Bear in mind that the database should be closed after use. </p>

<h5>Examples</h5>

<p>The greater-than symbol followed by a space (<code class="java">&gt; </code>) represents the user input. Note that it's not part of the input.</p>

<p>During tests, you are given a test directory. Input is a folder path, where you need to find and process all text files. Your program should take this path and iterate over files. Clear your database after each test.</p>

<p><strong>Example 1</strong>: <em>One file with one word in it</em></p>

<p>Folder contents: <em>testfile1.txt</em></p>

<p>File contents<span style="background-color: transparent; color: #000000; font-size: 11pt; font-variant: normal;">: </span><code class="java">student</code></p>

<pre><code class="language-no-highlight">&gt; tests/stage2/ex1
{
    'student': {'testfile1.txt': [[0, 0, 7]]}
}</code></pre>

<p><strong>Example 2</strong>: <em>Two files with strings</em></p>

<p>Folder contents: <em>testfile2.txt</em><samp><em>,</em></samp><em>testfile3.txt</em></p>

<p><em>testfile2.txt</em><em> </em>contents: <code class="java">John is @ student</code></p>

<p> The output of <em>testfile2.txt</em>:</p>

<pre><code class="language-no-highlight">{
    'John': {'testfile2.txt': [[0, 0, 4]]},
    'is': {'testfile2.txt': [[0, 5, 7]]},
    'student': {'testfile2.txt': [[0, 10, 17]]}
}</code></pre>

<p><em>testfile3.txt c</em>ontents:  <code class="java">Mary loves John</code></p>

<p>The output of <em>testfile3.txt:</em></p>

<pre><code class="language-no-highlight">&gt; tests/stage2/ex2
{
    'John': {'testfile2.txt': [[0, 0, 4]],
    'testfile3.txt': [[0, 11, 15]]},
    'is': {'testfile2.txt': [[0, 5, 7]]},
    'student': {'testfile2.txt': [[0, 10, 17]]},
    'Mary': {'testfile3.txt': [[0, 0, 4]]},
    'loves': {'testfile3.txt': [[0, 5, 10]]},
}</code></pre>

<p><strong>Example 3:</strong><em> </em><em>One file with two strings</em></p>

<p>Folder contents: <em>testfile4.txt</em></p>

<p><em>testfile4.txt </em>contents: <code class="java">Her true self was poorly concealed \n Her eyes were her own.</code></p>

<p>Output: one database containing pairs from the file</p>

<pre><code class="language-no-highlight">&gt; tests/stage2/ex3
{
    Her: {'testfile4.txt': [[0, 0, 3], [0, 36, 39]]};
    true: {'testfile4.txt': [[0, 4, 8]]};
    self: {'testfile4.txt': [[0, 9, 13]]};
    was: {'testfile4.txt': [[0, 14, 17]]};
    poorly: {'testfile4.txt': [[0, 18, 24]]};
    concealed: {'testfile4.txt': [[0, 25, 34]]};
    eyes: {'testfile4.txt': [[0, 40, 44]]};
    were: {'testfile4.txt': [[0, 45, 49]]};
    her: {'testfile4.txt': [[0, 50, 53]]};
    own: {'testfile4.txt': [[0, 54, 57]]}
}</code></pre>

<p><strong>Example 4</strong>: <em>An empty file</em></p>

<p>Folder content: <em>testfile5.txt</em></p>

<p>File contents: empty</p>

<pre><code class="language-no-highlight">&gt; tests/stage2/ex4

</code></pre>

<h3>Task 3</h3>

<h5><strong style="background-color: transparent; color: #000000; font-size: 11pt; font-variant: normal;"></strong>Description</h5>

<p>In this stage, you will create a simple search program. Let's start! A search engine looks for token coordinates in the database that you have created. Once the texts are tokenized and indexed, you will be able to get a list of all token positions. A good engine should process and find several tokens in one string. A good engine also should be able to process a set of documents. Even though you are not making a browser version of the search engine in this project, it may be a good idea to think about how to display the results, as there may be too many search results. Imagine you went through 10 documents and found a certain number of positions in each of them. Maybe you do not want to look through all the documents, as the first three are enough. You need to think about some kind of a limiter to output (also known as <strong>limit</strong>) only the necessary documents. A limit is a number that controls how many search results to display. If there are 10 documents, and you need to display only 3 of them, then the limit will be 3, and only three documents will be displayed as a search result. We also have a parameter called <strong>offset.</strong> An offset is also a number, but it stands for the sequential number of the document that you want to show. For example, you still want to see three documents, and you want to start not from the first, but from the fifth document. Then the result will show three documents that come under the numbers five, six, and seven in the original search array.</p>

<h5>Objectives</h5>

<p>To successfully complete this stage your program should:</p>

<ol>
	<li>Take a directory from the input.</li>
	<li>Tokenize and index each file from the directory and create a database (as in the previous step).</li>
	<li>Take a query (a line of words), the limit, and the offset.</li>
	<li>Tokenize it and remember the words.</li>
	<li>Find each token in the database with its filename and positions.</li>
	<li>Get the names of the files containing all tokens; if you have several text files in the database and want to find two words there, then you only need those files where both of these words are encountered. The distance between these tokens in one file is not relevant.</li>
	<li>Sort by filenames and shorten the results by limit and offset; note that the offset should be more than 0; if it is a negative number, set the offset to 0 automatically. If the limit is bigger than the total amount of files, the limit should be set at this exact amount (beware, the limit can be 0; in this case, no results should be displayed).</li>
	<li>Return the data from the database; one or several filenames and all corresponding token positions for query tokens —<code class="java">{'filename.txt': [[first_position], [second_position]]}</code>;</li>
	<li> Print the results in the following format: <code class="java">&lt;filename_1&gt;: a list of positions; &lt;filename_2&gt;: a list of positions</code> so that they can be checked.</li>
</ol>

<p>Sort the word positions in ascending order. It means that if you are looking for two words in a file, the first position in the list should be that of a token that occurred the first.</p>

<p>If a word is not found in the database, output an empty dictionary. If several words are given in a query, and at least one of them is missing, output an empty dictionary as well.</p>

<p>Do not forget to test your code. You need to create text files, index them, and build a small test base using the indexer. This time, check whether your program works when:</p>

<ul>
	<li>There is one file,</li>
	<li>There are a lot of files,</li>
	<li>Some or all words in the query cannot be found in the database.</li>
</ul>

<p>Clear the database after indexing.</p>

<h5>Examples</h5>

<p>The greater-than symbol followed by a space (<code class="java">&gt; </code>) represents the user input. Note that it's not part of the input.</p>

<p>During tests, you are given a test directory. Input is a folder path, where you need to find and process all text files. Your program should take this path and iterate over files. Clear your database after each test.</p>

<p><strong>Example 1: </strong><em>You are looking for one word and need only one file</em></p>

<p>Folder contents: <em>testfile1.txt</em>, <em>testfile2.txt</em>, <em>testfile3.txt</em></p>

<p><em>testfile1.txt </em>contents:<br>
<code class="java">Scarlett made a mouth of bored impatience.</code></p>

<p><em>testfile2.txt </em>contents:<br>
<code class="java">Look, Scarlett. About tomorrow</code></p>

<p><em>testfile3.txt </em>contents:<br>
<code class="java">Hello, world!!!</code></p>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; tests/stage3/ex1
&gt; 'Scarlett',1,0
testfile1.txt: [[0, 0, 8]]</code></pre>

<p><strong>Example 2</strong>: <em>You have three files, you are looking look for several words and need two files starting from the second one</em></p>

<p>Folder contents: <em>testfile4.txt, testfile5.txt, testfile6.txt</em></p>

<p><em>testfile4.txt</em> contents:<br>
<code class="java">Seated with Stuart and Brent Tarleton, she made a pretty picture.</code></p>

<p><em>testfile5.txt </em>contents:<br>
<code class="java">Stuart and Brent considered their latest expulsion a fine joke.</code></p>

<p><em>testfile6.txt </em>contents:<br>
<code class="java">It was for this precise reason that Stuart and Brent were idling on the porch of Tara this April afternoon.</code></p>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; tests/stage3/ex2
&gt; 'Stuart and Brent',5,1
testfile5.txt: [[0, 0, 6], [0, 7, 10], [0, 11, 16]]; testfile6.txt: [[0, 36, 42], [0, 43, 46], [0, 47, 52]]</code></pre>

<p><strong>Example 3</strong>: <em>No such words in files</em></p>

<p>Folder contents: <em>testfile7.txt</em>, <em>testfile8.txt</em></p>

<p><em>testfile7.txt </em>contents:<br>
<code class="java">Although born to the ease of plantation life, the faces of the three  were neither slack nor soft.</code></p>

<p><em>testfile8.txt </em>contents:<br>
<code class="java">Scarlett O’Hara was not beautiful, but men seldom realized it </code></p>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; tests/stage3/ex3
&gt; 'Natasha Rostova',1,1

</code></pre>

<p><strong>Example 4</strong>:<em> </em><em>Limit is zero</em></p>

<p>Folder contents: <em>testfile9.txt</em>, <em>testfile10.txt</em></p>

<p><em>testfile9.txt </em>contents:<br>
<code class="java">The war, goose! The war’s going to start any day.</code></p>

<p><em>testfile10.txt </em>contents:<br>
<code class="java">You know there isn’t going to be any war, It’s all just talk.</code></p>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; tests/stage3/ex4
&gt; 'war',0,0

</code></pre>
<h3>Task 4</h3>

<h5>Description</h5>

<p>In this stage, we will focus on how to display what you have found to a user in a readable form. We need to create a context window for any token for this. A context window is the token's environment, in other words, other tokens on the left and right. There can be a lot of them — two or ten. The goal is to immediately show a context window for each position in the list. For example, we have a line: <code class="java">John and Mary are students and they live in London</code>. You want to create a context window for <code class="java">in</code> with one token on the left and right. The result is a context window that has:</p>

<ul>
	<li>The <code class="java">John and Mary are students and they live in London</code> line. It is important to include the whole line for the next steps, where you will extend the borders of the window to match the sentence's borders. If the token is the first/last in the file, there is no need to move to the next/previous line to fill the context window;</li>
	<li>The position of the token, for example, <code class="java">0, 41, 43</code>;</li>
	<li>The indexes of the context window borders, where the first index is the start of the first token in the window, <code class="java">live</code> in our case and the end of the last token in the window, <code class="java">London</code>.</li>
</ul>

<p>The context window may include more than one sentence; if the word was the last in the sentence with the window size of 4, then include a part of the next sentence.</p>

<h5>Objectives</h5>

<p>Write a program that creates a context window for a token. Later, you will be able to run this function several times for each token that needs a window. For now, the program should:</p>

<ol>
	<li>Take a folder with files as an input, iterate over it, read the data from the input about the position of a token and the size of the window for each file; the filenames, the positions of the tokens, and the window sizes are placed in one input string and are separated by semicolumns, for example, <code class="java">testfile1.txt;0,0,6;2</code>. Note that if the window size is 0, the program should return an empty string.</li>
	<li>Find the line with the token and tokenize the line from left to right and vise versa. It is done to find the positions of the neighboring tokens, depending on the window size.</li>
	<li>Remember the beginning and the end of the window.</li>
	<li>Write down the positions in the nested list, for example, <code class="java">[[0, 0, 6]]</code>. There can be several tokens in the context window if the request consists of more than one word. It will also be required for the next stages.</li>
	<li>Print the context window as a string, where all attributes of the window are separated from each other by the <code class="java">|</code> symbol; see more examples below.</li>
</ol>

<p>Don't forget to test your program. Check whether your program works when:</p>

<ul>
	<li>The token is the first/last in a line;</li>
	<li>There are empty lines in the file;</li>
	<li>There is no such token in the file.</li>
</ul>

<p>Clear the database immediately after indexing.</p>

<h5>Examples</h5>

<p>The greater-than symbol followed by a space (<code class="java">&gt; </code>) represents the user input. Note that it's not part of the input.</p>

<p>During tests, you are given a test directory. Input is a folder path, where you need to find and process all text files. Your program should take this path and iterate over files. Clear your database after each test.</p>

<p><strong>Example 1</strong>: <em>The token is first, the window size is two</em></p>

<p>Folder contents: <em>testfile1.txt</em></p>

<p><em>testfile1.txt </em>contents:<br>
<code class="java">Spring had come early that year.</code></p>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; tests/stage4/ex1
&gt; testfile1.txt;0,0,6;2
Spring had come early that year.|[[0, 0, 6]]|0|15</code></pre>

<p><strong>Example 2</strong>: <em>The token is in the middle of the string, the window size is one</em></p>

<p>Folder contents: <em>testfile2.txt</em></p>

<p><em>testfile2.txt </em>contents:</p>

<pre><code class="language-no-highlight">Spring had come early that year.
He had come on tuesday night.</code></pre>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; ex2
&gt; testfile2.txt;1,7,11;1
He had come on tuesday night.|[[1, 7, 11]]|3|14</code></pre>

<p><strong>Example 3</strong>: <em>The token is the last in the string, the window size is three</em></p>

<p>Folder contents: <em>testfile3.txt</em></p>

<p><em>testfile3.txt </em>contents:<br>
<code class="java">Spring had come early that year.</code></p>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; ex3
&gt; testfile3.txt;0,27,31;3
Spring had come early that year.|[[0, 27, 31]]|11|31</code></pre>

<p><strong>Example 4</strong>: <em>The window size is zero</em></p>

<p>Folder contents: <em>testfile4.txt</em></p>

<p><em>testfile4.txt </em>contents:<br>
<code class="java">You can always tell weather by sunsets.</code></p>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; ex4
&gt; testfile4.txt;0,15,19;0


</code></pre>
<h3>Task 5</h3>

<h5>Description</h5>

<p>Work with context windows to make them pretty and convenient. You should highlight the words from the query, merge several windows into one if they are overlapping, and extend the borders of the windows so that they can match a whole sentence.</p>

<p>First, you need to check the windows for overlapping. It happens when two windows (A and B) are in the same line, but the ending index of A is less than (or equal to) the starting index of B, or the ending index of A is bigger (or equal to) than the starting index of B. The windows also overlap when their borders coincide.</p>

<p>If the windows do overlap, combine them into one. You need to find their joint starting and ending index and then assign this new index as new. The resulting list should include both positions (see the examples below).</p>

<p>Further, you need to extend the window's borders to match a sentence. For example, you have a window size of 2, and the following line: <code class="language-html">Spring had come early that year</code>. The token position is <code class="language-html">[0,0,6]</code> , the window borders are 0 and 15. Now you need to find the end of this sentence and assign new window borders — 0 and 31.</p>

<p>One more example of overlapping windows. You have a small sentence: <code class="language-html">Mary and Lisa went shopping in town</code>. There are two context windows for the query we are looking for: <code class="language-html">Mary and Lisa</code> and <code class="language-html">Lisa went shopping</code>. The <code class="language-html">Lisa</code> token is overlapping, so they should be combined into <code class="language-html">Mary and Lisa went shopping</code>. However, this is not the whole sentence, so extended to the very end of the sentence.</p>

<p>The sentence boundaries may be obscure as there are all sorts of abbreviations, initials, and other stuff. Punctuation marks can help you with that, you can use <a target="_blank" href="https://docs.python.org/3/library/re.html" rel="noopener noreferrer nofollow">ready-made patterns</a> with <code class="language-html">re</code>:</p>

<pre><code class="language-no-highlight">PATTERN = re.compile(r’[\.!?]+')</code></pre>

<p>The last feature should highlight the words from the query. It uses tags <code class="language-html">&lt;b&gt;</code> and <code class="language-html">&lt;/b&gt;</code> and inserts them at the begging and to the end of a token to make it bold. For example, you have the following context window: <code class="language-html">Spring had come early that year.</code> for a <code class="language-html">Spring</code> query, the pattern would highlight the word: <code class="language-html">&lt;b&gt;Spring&lt;/b&gt;<strong> </strong>had come early that year.</code> If there is more than one word in a query, then each of them would be highlighted. These tags work with the HTML markup. It can be important if you want to write a search interface after completing a project.</p>

<h5>Objectives</h5>

<p>During testing, you will get two context windows as input (strings). Your output should either consist of two independent windows with extended boundaries and query words highlighted or of one combined window in case the given windows overlap, also with extended boundaries and words highlighted. So your program should do the following:</p>

<ol>
	<li>If there are two windows, check whether they overlap.</li>
	<li>If they overlap, combine them into one.</li>
	<li>If you have one window, take it as input and expand its boundaries.</li>
	<li>Attach tags <code class="language-html">&lt;b&gt;</code> and <code class="language-html">&lt;/b&gt;</code> to the start and the end of the main tokens.</li>
</ol>

<p>Let's break it down. The first window is a <code class="language-html">Spring had come early that year.</code> line, the token position is <code class="language-html">[0,0,6]</code>, window borders are 0 and 15. The second window is a <code class="language-html">Spring had come early that year.</code> line, the token position is <code class="language-html">[0,11,15]</code>, window borders 7 and 21. <code class="language-html">Spring had come</code> is overlapping the second window <code class="language-html">had come early</code>. Combine them to get a new <code class="language-html">Spring had come early</code> window, the window borders are 0 and 21, the positions are <code class="language-html">[[0,0,6], [0,11,15]]</code>. Extend the window to <code class="language-html">&lt;b&gt;Spring&lt;/b&gt; had &lt;b&gt;come&lt;/b&gt; early that year.</code>, the borders are 0 and 31, the positions are represented as a <code class="language-html">[[0,0,6], [0,11,15]]</code> list .</p>

<p>Note that the output should contain one window, printed like in the previous stage if the given windows are overlapping, and two windows, printed one after another if the windows do not overlap.</p>

<h5>Examples</h5>

<p>The greater-than symbol followed by a space (<code class="language-html">&gt; </code>) represents the user input. Note that it's not part of the input.</p>

<p><strong>Example 1</strong>: <em>Windows are overlapping</em></p>

<p>Input: two windows, the window size is two.</p>

<p>Output: one window (since the first window goes to the second sentence and merges with the second window); the line consists of two sentences</p>

<pre><code class="language-html">&gt; I feel sure she loves lilies. And they are so appropriate to a bride.|[[0, 22, 28]]|12|38
&gt; I feel sure she loves lilies. And they are so appropriate to a bride.|[[0, 34, 38]]|22|45
I feel sure she loves &lt;b&gt;lilies&lt;/b&gt;. And &lt;b&gt;they&lt;/b&gt; are so appropriate to a bride.|[[0, 22, 28], [0, 34, 38]]|0|69</code></pre>

<p><strong>Example 2</strong>: <em>Windows are overlapping within one sentence</em></p>

<p>Input: two windows, the window size is 1</p>

<p>Output: one window</p>

<pre><code class="language-html">&gt; You know you promised to obey.|[[0, 9, 12]]|4|21
&gt; You know you promised to obey.|[[0, 13, 21]]|9|24
You know &lt;b&gt;you&lt;/b&gt; &lt;b&gt;promised&lt;/b&gt; to obey.|[[0, 9, 12], [0, 13, 21]]|0|30</code></pre>

<p><strong>Example 3</strong>: <em>Windows are not overlapping</em> </p>

<p>Input: two windows, the window size is one</p>

<p>Output: two windows</p>

<pre><code class="language-html">&gt; Oh, by the by, dear, I shan’t be able to go with you today. I’ve rather a headache.|[[0, 53, 58]]|49|58
&gt; Oh, by the by, dear, I shan’t be able to go with you today. I’ve rather a headache.|[[0, 74, 82]]|72|82
Oh, by the by, dear, I shan’t be able to go with you &lt;b&gt;today&lt;/b&gt;.|[[0, 53, 58]]|0|59
I’ve rather a &lt;b&gt;headache&lt;/b&gt;.|[[0, 74, 82]]|60|83</code></pre>

<p><strong>Example 4</strong>: <em>Windows are not overlapping within one sentence</em></p>

<p>Input: two windows, the window size is one</p>

<p>Output: there will be two windows with the same line</p>

<pre><code class="language-html">&gt; Yes, she must be clever to have obtained the position that she has.|[[0, 5, 8]]|0|13
&gt; Yes, she must be clever to have obtained the position that she has.|[[0, 45, 53]]|41|58
Yes, &lt;b&gt;she&lt;/b&gt; must be clever to have obtained the position that she has.|[[0, 5, 8]]|0|67
Yes, she must be clever to have obtained the &lt;b&gt;position&lt;/b&gt; that she has.|[[0, 45, 53]]|0|67</code></pre>
<h3>Task 6</h3>

<h5>Description</h5>

<p>In this stage, complete the following steps:</p>

<ol>
	<li> Learn how to make context windows out of a dictionary with positions;</li>
	<li> Combine the first step with the features from the previous stages. The program should return windows, processed as in the previous stage.</li>
</ol>

<h5>Objectives</h5>

<p>Your program is given a folder with files. The program processes them and returns a dictionary with context windows. Then these windows should be converted into a dictionary with combined and expanded windows with their number adjusted by limit and offset.</p>

<p>In more detail, it should do the following:</p>

<ol>
	<li>Take an input that consists of a dictionary, a query, a window size, a limit, and an offset: <code class="java">input_dictionary,query='man', window_size=1, limit=1, offset=0</code>.</li>
	<li>A dictionary can look like this: <code class="java">{'filename.txt': [first_position, second_position, ...]}</code> , it is the result of the search. Note that the context window size remains constant;</li>
	<li>Iterate over all positions in each file;</li>
	<li>Create a context window from each position;</li>
	<li>Save context windows in a corresponding dictionary: <code class="java">{'filename.txt': [window1, window2, ...]}</code>;</li>
	<li>Extend all windows to match sentences;</li>
	<li>Test whether the windows overlap. If so, merge them into one and save only the result of merging. Note that before this step you worked only with two windows that either overlapped or not. Now, you have a dictionary with a lot of windows, so you should iterate over the dictionary, taking two consecutive windows each time to check whether they overlap or not. If they do not overlap, take the next two consecutive windows and repeat the action;</li>
	<li>Save the results in the output dictionary: <code class="java">{'filename.txt': [window1, window2, ...]}</code>. Do not forget that you need to save as many files with their context window lists as indicated in the limit. Start from the index of the result that is indicated in the offset; see the example below;</li>
	<li>Sort the dictionary in ascending order and print the result in the following format: <code class="java">filename_1: list with windows_1\nfilename_2: list with windows_2</code></li>
	<li>Clear the database after indexing</li>
</ol>

<h5>Examples</h5>

<p>The greater-than symbol followed by a space (<code class="java">&gt; </code>) represents the user input. Note that it's not part of the input.</p>

<p>During tests, you are given a test folder. Input is a folder path, where you need to find and process all text files. Your program should take this path and iterate over files. Clear your database after each test.</p>

<p><strong>Example 1</strong>:</p>

<p>Folder contents: <em>testfile1.txt, testfile2.txt.</em></p>

<p><em>testfile1.txt </em>contents:<br>
<code class="java">It seemed a delightful prospect. This man evidently understands my complaint.</code></p>

<p><em>testfile2.txt </em>contents:<br>
<code class="java">Every possible situation man could imagine has been spoilt.</code></p>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; tests/stage6/ex1
&gt; 'man',1,1,0
testfile1.txt: ['It seemed a delightful prospect. This man evidently understands my complaint.|[[0, 38, 41]]|33|78']</code></pre>

<p><strong>Example 2</strong>:</p>

<p>Folder contents: <em>testfile3.txt</em>.</p>

<p><em>testfile3.txt </em>contents:</p>

<pre><code class="language-no-highlight">There’s enough water to see, right?
To tell the truth, it was water from the river, too.</code></pre>

<p>Output: </p>

<pre><code class="language-no-highlight">&gt; tests/stage6/ex2
&gt; 'water',1,2,0
testfile3.txt: ['There’s enough water to see, right?|[[0, 15, 20]]|0|36', 'To tell the truth, it was water from the river, too.|[[1, 26, 31]]|0|53']</code></pre>
<h3>Task 7</h3>

<h5>Description</h5>

<p>Welcome to the final stage of the project!</p>

<p>You need to take the attached <a target="_blank" href="https://stepik.org/media/attachments/lesson/383392/tests.rar" rel="noopener noreferrer nofollow">folder</a> and make a new database. In previous stages, the files and databases you created were for educational purposes, they served only to check your program. Now, it's time to create a real search engine with real-world text files. In this case, you will work with short stories of Jerome Klapka Jerome. Note that indexing the database may take a while because the files are much bigger than in all previous stages.</p>

<p>In this stage, perform a search in this new database. Also, you need a function that searches for a query in the database and returns the pairs — <code class="language-html">filename: contexts with the query words</code> in string format. You already know how to adjust the number of documents using limit and offset, now you need to do the same with <strong>quotes</strong> in the files. By quotes, we understand sentences from the indexed files that contain the query words.</p>

<p>As a result, your search should return a limited number of documents starting from the document offset, and also a limited number of quotes, starting from the quotes offset. Note that limits and offsets for documents and quotes are different!</p>

<h5>Objectives</h5>

<p>Your search at this stage should:</p>

<ol>
	<li>Take a query, a window size, a limit, and an offset, and a list of pairs (a limit, an offset) for quotes in documents as input; for example, you want to find the word <code class="language-html">'man'</code> , with limit=3, offset=0. You want three quotes starting from the first and the window size is one, so the input would look like this: <code class="language-html">query='man', window_size=1, limit=3, offset=0, pairs=[(3,0),(3,0),(3,0)]</code>;</li>
	<li>Implement the second function from the previous stage and get a dictionary with context windows;</li>
	<li>Take the corresponding pair (limit, offset) from the list for each file, and if the pair is missing, use the default values — limit=3, offset=0. Once the interface is done, users will be able to use them as default values if they do not want to set their own.</li>
	<li>Take the required number of quotes from the document according to the limit and offset. Be careful, the offset should be more or equal to 0! Otherwise, set the offset to 0 automatically. If the limit is bigger than the total amount of files you have, set the limit to the number of documents. At the same time, if the limit is 0, no results should be displayed,</li>
	<li> Highlight the keywords in bold for each quote,</li>
	<li> Return the resulting dictionary, which will look like this <code class="language-html">{'filename_one.txt': [quote0, quote1, quote2, ...], 'filename_two.txt': [quote0, quote1, quote2], 'filename_three.txt': ..., ...}</code>.</li>
	<li>Print the results in the following manner:
	<pre><code class="language-no-highlight">filename 1
 1.Line 1
 2.Line 2
 3.Line 3

filename 2
 1.Line 1
 2.Line 2
 3.Line 3</code></pre>
	</li>
</ol>

<h5>Examples</h5>

<p>The greater-than symbol followed by a space (<code class="language-html">&gt; </code>) represents the user input. Note that it's not part of the input.</p>

<p>You are working with large texts, so we show only the inputs and outputs.</p>

<p>During tests, you are given a folder; there are 4 files with a story in each.</p>

<p>Folder contents:<em> </em><em>story_one.txt</em>, <em>story_two.txt</em>, <em>story_three.txt</em>, <em>story_four.txt</em>.</p>

<p><strong>Example 1</strong>: <em>The limit is bigger than the total amount of files in the database</em></p>

<pre><code class="language-html">&gt; ex
&gt; 'George';1;3;0;1,0;1,0;2,0
story_one.txt
1. We found ourselves short of water at Hambledon Lock; so we took our jar and went up to the lock-keeper’s house to beg for some. &lt;b&gt;George&lt;/b&gt; was our spokesman.
story_three.txt
1. &lt;b&gt;George&lt;/b&gt; raised his hat, and said “Good-morning.” He hoped, in answer to his politeness, to hear the polite “Welcome to our shop,” as this was the answer in the conversation book.
story_two.txt
1. We had made the tea, and were just settling down comfortably to drink it, when &lt;b&gt;George&lt;/b&gt;, with his cup half-way to his lips, paused and exclaimed: “What’s that?”
2. “Why that!” said &lt;b&gt;George&lt;/b&gt;, looking westward.</code></pre>

<p><strong>Example 2</strong>: <em>Different limits and offsets for each document</em></p>

<p>This example demonstrates the functionality of limits: you would have printed the results for all four files, but since the limit is set to 3, you need only three first outputs.</p>

<pre><code class="language-html">&gt; ex
&gt; 'Hambledon Lock';2;3;0;1,0;2,0;1,0
story_one.txt
1. We found ourselves short of water at &lt;b&gt;Hambledon&lt;/b&gt; &lt;b&gt;Lock&lt;/b&gt;; so we took our jar and went up to the lock-keeper’s house to beg for some.</code></pre>

<p><strong>Example 3</strong>: <em>One result in one file</em></p>

<pre><code class="language-html">&gt; ex
&gt; 'water';3;4;0;3,0;1,0;2,0;4,0
story_four.txt
1. I drank them neat for six consecutive days, and they nearly killed me; but after then I adopted the plan of taking a stiff glass of brandy-and-&lt;b&gt;water&lt;/b&gt; immediately on the top of them, and found much relief thereby.
2. I have been informed since, by various eminent medical gentlemen, that the alcohol must have entirely counteracted the effects of the chalybeate properties contained in the &lt;b&gt;water&lt;/b&gt;. I am glad I was lucky enough to hit upon the right thing.
story_one.txt
1. We found ourselves short of &lt;b&gt;water&lt;/b&gt; at Hambledon Lock; so we took our jar and went up to the lock-keeper’s house to beg for some.
story_two.txt
1. We tried river &lt;b&gt;water&lt;/b&gt; once, later on in the season, but it was not a success.
2. Our jar was empty, and it was a case of going without our tea or taking &lt;b&gt;water&lt;/b&gt; from the river.</code></pre>

<p><strong>Example 4</strong>: <em>The word does not exist</em></p>

<pre><code class="language-no-highlight">&gt; ex
&gt; 'Count Dracula';2;4;1;2,0;2,0;3,0;1,0

</code></pre>

<p><strong>Example 5</strong>: <em>The limit is zero</em></p>

<pre><code class="language-no-highlight">&gt; ex
&gt; 'Scarlett';4;0;0;1,0;5,0;3,0;1,0

</code></pre>
